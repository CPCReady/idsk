#!/bin/bash
# iDSK Disk Documentation Generator
# Usage: ./generate-disk-readme.sh <disk.dsk> [output_readme.txt]

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default paths
IDSK_BINARY="$PROJECT_ROOT/build/iDSK"
if [ ! -f "$IDSK_BINARY" ]; then
    IDSK_BINARY="$PROJECT_ROOT/scripts/iDSK"
fi
if [ ! -f "$IDSK_BINARY" ]; then
    IDSK_BINARY="idsk"  # Try system PATH
fi

usage() {
    echo "iDSK CPCReady Disk Documentation Generator"
    echo ""
    echo "Usage: $0 <dsk_file> [options]"
    echo ""
    echo "Options:"
    echo "  -v, --verbose    Enable verbose output"
    echo "  -o, --output     Specify output filename"
    echo "  -h, --help       Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 game.dsk"
    echo "  $0 game.dsk --verbose"
    echo "  $0 game.dsk --output game_info.txt"
}

log() {
    if [ "$VERBOSE" = true ]; then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --verbose|-v)
            VERBOSE=true
            ;;
        --output|-o)
            shift
            if [[ -z "$1" ]]; then
                echo "[ERROR] --output requires a filename" >&2
                exit 1
            fi
            OUTPUT_FILE="$1"
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        --*)
            echo "[ERROR] Unknown option: $1" >&2
            exit 1
            ;;
        *)
            if [[ -z "$DSK_FILE" ]]; then
                DSK_FILE="$1"
            else
                echo "[ERROR] Unknown argument: $1" >&2
                exit 1
            fi
            ;;
    esac
    shift
done

if [ -z "$DSK_FILE" ]; then
    error "DSK file is required. Use --help for usage information."
fi

if [ ! -f "$DSK_FILE" ]; then
    error "DSK file not found: $DSK_FILE"
fi

# Check if iDSK is available
if ! command -v "$IDSK_BINARY" >/dev/null 2>&1; then
    error "iDSK binary not found. Please build iDSK first or ensure it's in PATH."
fi

# Generate output filename if not provided
if [ -z "$OUTPUT_FILE" ]; then
    DISK_NAME=$(basename "$DSK_FILE" .dsk)
    DISK_NAME_UPPER=$(echo "$DISK_NAME" | tr '[:lower:]' '[:upper:]')
    OUTPUT_FILE="README_${DISK_NAME_UPPER}.txt"
fi

log "Analyzing DSK file: $DSK_FILE"
log "Output file: $OUTPUT_FILE"
log "iDSK binary: $IDSK_BINARY"

# Get disk information
log "Reading disk catalog..."
DISK_LISTING=$("$IDSK_BINARY" "$DSK_FILE" -l 2>/dev/null | grep -v "DSK :" | grep -v "^----" | grep -v "^$" || true)

if [ -z "$DISK_LISTING" ]; then
    warn "Disk appears to be empty or unreadable"
    DISK_LISTING="(Empty disk)"
fi

# Count files by type
BASIC_FILES=$(echo "$DISK_LISTING" | grep -i "\.BAS" | wc -l | tr -d ' ')
BINARY_FILES=$(echo "$DISK_LISTING" | grep -i "\.BIN" | wc -l | tr -d ' ')
TEXT_FILES=$(echo "$DISK_LISTING" | grep -i -E "\.(TXT|DOC)" | wc -l | tr -d ' ')
OTHER_FILES=$(echo "$DISK_LISTING" | grep -v -i -E "\.(BAS|BIN|TXT|DOC)" | wc -l | tr -d ' ')
TOTAL_FILES=$(echo "$DISK_LISTING" | wc -l | tr -d ' ')

# Get disk size
DISK_SIZE=$(stat -f%z "$DSK_FILE" 2>/dev/null || stat -c%s "$DSK_FILE" 2>/dev/null || echo "Unknown")

# Generate README content
log "Generating documentation..."

cat > "$OUTPUT_FILE" << EOF
$(echo "$(basename "$DSK_FILE" .dsk)" | tr '[:lower:]' '[:upper:]') DISK DOCUMENTATION
================================================================

Generated by iDSK CPCReady Disk Documentation Generator
Created: $(date '+%Y-%m-%d %H:%M:%S')
Disk file: $DSK_FILE
Disk size: $DISK_SIZE bytes

DISK SUMMARY
============
Total files: $TOTAL_FILES
- BASIC programs: $BASIC_FILES
- Binary files: $BINARY_FILES  
- Text files: $TEXT_FILES
- Other files: $OTHER_FILES

FILE LISTING
============
EOF

# Add detailed file listing
if [ "$DISK_LISTING" != "(Empty disk)" ]; then
    echo "$DISK_LISTING" | while IFS= read -r line; do
        if [ -n "$line" ]; then
            # Parse the line more carefully - format is typically "FILENAME .EXT USER"
            FILENAME=$(echo "$line" | awk '{print $1}')
            EXTENSION=$(echo "$line" | awk '{print $2}')
            USER=$(echo "$line" | awk '{print $3}')
            
            # Handle cases where filename and extension are combined
            if [[ "$FILENAME" == *.* ]]; then
                FULL_NAME="$FILENAME"
                FILENAME=$(echo "$FULL_NAME" | cut -d'.' -f1)
                EXTENSION=".$(echo "$FULL_NAME" | cut -d'.' -f2)"
                USER="$EXTENSION"  # This might be the user number
            fi
            
            # Clean up extension
            EXTENSION=$(echo "$EXTENSION" | sed 's/^[^.]/./; s/[0-9]*$//')
            
            # Determine file type description
            case "$EXTENSION" in
                ".BAS")
                    TYPE_DESC="BASIC program"
                    ;;
                ".BIN")
                    TYPE_DESC="Binary executable"
                    ;;
                ".TXT"|".DOC")
                    TYPE_DESC="Text document"
                    ;;
                ".DAT")
                    TYPE_DESC="Data file"
                    ;;
                ".SCR")
                    TYPE_DESC="Screen data"
                    ;;
                *)
                    TYPE_DESC="File"
                    ;;
            esac
            
            printf "%-12s %-4s - %s\n" "$FILENAME" "$EXTENSION" "$TYPE_DESC" >> "$OUTPUT_FILE"
        fi
    done
else
    echo "(Empty disk)" >> "$OUTPUT_FILE"
fi

# Add program descriptions for BASIC files
BASIC_LIST=$(echo "$DISK_LISTING" | grep -i -E "\.(BAS|bas)" | awk '{print $1}' | sed 's/\..*$//' || true)
if [ -n "$BASIC_LIST" ] && [ "$BASIC_LIST" != "" ]; then
    cat >> "$OUTPUT_FILE" << EOF

BASIC PROGRAMS
==============
EOF

    echo "$BASIC_LIST" | while IFS= read -r basename; do
        if [ -n "$basename" ]; then
            # Try different extensions
            for ext in "bas" "BAS"; do
                basicfile="${basename}.${ext}"
                
                log "Analyzing BASIC program: $basicfile"
                
                # Try to get first few lines of BASIC program for description
                BASIC_CONTENT=$("$IDSK_BINARY" "$DSK_FILE" -b "$basicfile" 2>/dev/null | head -20 | grep -E "^[0-9]+" || true)
                
                if [ -n "$BASIC_CONTENT" ]; then
                    echo "" >> "$OUTPUT_FILE"
                    echo "$basename:" >> "$OUTPUT_FILE"
                    
                    # Look for REM statements that might describe the program
                    REM_LINES=$(echo "$BASIC_CONTENT" | grep -i "REM" | head -3 | sed 's/^[0-9]*[[:space:]]*REM[[:space:]]*/  - /' || true)
                    if [ -n "$REM_LINES" ]; then
                        echo "$REM_LINES" >> "$OUTPUT_FILE"
                    else
                        # Try to infer purpose from content
                        if echo "$BASIC_CONTENT" | grep -qi "MODE\|CLS\|PRINT"; then
                            echo "  - Interactive program with screen output" >> "$OUTPUT_FILE"
                        elif echo "$BASIC_CONTENT" | grep -qi "INPUT"; then
                            echo "  - Interactive program with user input" >> "$OUTPUT_FILE"
                        elif echo "$BASIC_CONTENT" | grep -qi "FOR\|WHILE\|GOTO"; then
                            echo "  - Program with loops/control flow" >> "$OUTPUT_FILE"
                        elif echo "$BASIC_CONTENT" | grep -qi "DRAW\|PLOT\|CIRCLE"; then
                            echo "  - Graphics/drawing program" >> "$OUTPUT_FILE"
                        else
                            echo "  - BASIC program" >> "$OUTPUT_FILE"
                        fi
                    fi
                    
                    # Show line count
                    LINE_COUNT=$(echo "$BASIC_CONTENT" | wc -l | tr -d ' ')
                    echo "  - Program lines: $LINE_COUNT" >> "$OUTPUT_FILE"
                    break
                fi
            done
        fi
    done
fi

# Add binary file information
BINARY_LIST=$(echo "$DISK_LISTING" | grep -i "\.BIN" | awk '{print $1 $2}' || true)
if [ -n "$BINARY_LIST" ] && [ "$BINARY_LIST" != "" ]; then
    cat >> "$OUTPUT_FILE" << EOF

BINARY FILES
============
EOF

    echo "$BINARY_LIST" | while IFS= read -r binfile; do
        if [ -n "$binfile" ]; then
            BASENAME=$(echo "$binfile" | sed 's/\.BIN$//')
            
            log "Analyzing binary file: $binfile"
            
            echo "" >> "$OUTPUT_FILE"
            echo "$BASENAME:" >> "$OUTPUT_FILE"
            
            # Try to get file size and type information
            HEX_CONTENT=$("$IDSK_BINARY" "$DSK_FILE" -h "$binfile" 2>/dev/null | head -5 || true)
            
            if [ -n "$HEX_CONTENT" ]; then
                # Extract apparent size from hex dump
                BYTE_COUNT=$(echo "$HEX_CONTENT" | wc -l | tr -d ' ')
                echo "  - Binary executable or data file" >> "$OUTPUT_FILE"
                echo "  - Hex dump lines: $BYTE_COUNT" >> "$OUTPUT_FILE"
                
                # Try to identify if it looks like Z80 code
                if echo "$HEX_CONTENT" | grep -q -E "(21|11|01|C3|C9|ED)"; then
                    echo "  - Appears to contain Z80 machine code" >> "$OUTPUT_FILE"
                fi
            else
                echo "  - Binary file (unable to analyze)" >> "$OUTPUT_FILE"
            fi
        fi
    done
fi

# Add usage instructions
cat >> "$OUTPUT_FILE" << EOF

USAGE INSTRUCTIONS
==================
To use this disk in an Amstrad CPC emulator:

1. Mount $(basename "$DSK_FILE") as drive A:
2. Type CAT to list files
3. For BASIC programs: RUN"filename (without .BAS extension)
4. For binary files: Load according to program documentation

BASIC Program Commands:
EOF

if [ -n "$BASIC_LIST" ] && [ "$BASIC_LIST" != "" ]; then
    echo "$BASIC_LIST" | while IFS= read -r basicfile; do
        if [ -n "$basicfile" ]; then
            BASENAME=$(echo "$basicfile" | sed 's/\.BAS$//')
            echo "- RUN\"$BASENAME" >> "$OUTPUT_FILE"
        fi
    done
else
    echo "- No BASIC programs found" >> "$OUTPUT_FILE"
fi

cat >> "$OUTPUT_FILE" << EOF

TECHNICAL INFORMATION
====================
Disk format: CPCEMU DSK
Compatible with: Amstrad CPC emulators (Arnold, WinAPE, etc.)
File system: CP/M with AMSDOS extensions

Generated with iDSK v0.20
Documentation generator: $(basename "$0")

For more information about iDSK CPCReady:
https://github.com/CPCReady/idsk
EOF

success "Documentation generated: $OUTPUT_FILE"

# Add to disk if requested
if [ "$ADD_TO_DISK" = true ]; then
    log "Adding README to disk..."
    
    # Create a disk-compatible name (8.3 format)
    DISK_README="README_D.TXT"
    
    # Try to add to disk
    if "$IDSK_BINARY" "$DSK_FILE" -i "$OUTPUT_FILE" -t 0 -f 2>/dev/null; then
        success "README added to disk as $DISK_README"
    else
        warn "Could not add README to disk (disk may be full)"
    fi
fi

# Show summary
echo ""
log "Summary:"
log "- Analyzed: $DSK_FILE"
log "- Found: $TOTAL_FILES files ($BASIC_FILES BASIC, $BINARY_FILES binary, $TEXT_FILES text, $OTHER_FILES other)"
log "- Generated: $OUTPUT_FILE"
if [ "$ADD_TO_DISK" = true ]; then
    log "- Added to disk: $DISK_README"
fi

echo ""
success "Disk documentation complete!"
echo "View the documentation: cat $OUTPUT_FILE"